
## 参考

## 区块链
### 定义
区块链是由一个共享的、容错的分布式数据库和多节点网络节点组成的

+ 在区块链分布式数据库中：
    + 数据通过共识算法以块的形式增加，不可以修改或者删除，防止被恶意篡改
    + 每个区块都至少会包含一个块的生成时间和签名，新增区块上会存储上一个区块的哈希值，以此与上一个区块相连
    + 所有的交易数据都会被双方签名，防止抵赖
+ 在区块链多节点网络中：
    + 所有节点都可以浏览所有区块
    + 所有节点都可以验证区块，参与共识算法，即可以通过共识算法增加区块
+ 主要构成技术：
    + p2p技术，点对点传输，bt协议的支撑技术
    + 共识算法，是区块链能够保证不被篡改的核心，即保证数据是可信的
    + 椭圆加密算法，公钥私钥，数字签名等密码学算法
    + 默克尔树，区块链数据存储的数据结构

其实区块链本质上就是一种分布式数据库，一些分布式数据库的特性也适用于区块链，但由于区块链大部分是公链或联盟链的原因，
并且需要达到数据的强一致性和不可篡改的特性，区块链牺牲了很多分布式数据库的优点，当然也带来了一些分布式数据库没有的特性。

### 背景
2009年，Satoshi Nakamoto建立了第一个区块链系统——比特币，这是一种分布式的点对点系统，主要为了支持货币交易。
之后随着ETH的发展，智能合约给区块链带来了极大的技术变革，他帮助应用开发者极大地缩短了开发时间。
如今在不同领域，存在着各式各样的区块链系统，这些区块链的核心不是p2p通信方式或密码学加密/签名，而是区块链里的共识算法。

### 挖矿/共识算法
挖矿是一种创造区块的过程，这种区块是可以被验证并且添加到分布式数据库中的数据块。在比特币或ETH中，
矿工可以通过挖矿从系统中获得奖励，这些参与挖矿的节点被称为矿工。

理论上，每个可接入的节点都可以称为矿工，但不一定有机会成为矿工。

挖矿是一种周期性的竞争行为，根据共识算法的不同，在每个挖矿的周期从矿工中选出赢家的方式也不尽相同，赢家也被成为出块者。

1. 工作量证明：PoW是比特币中是用的共识算法，它需要矿工参与一场困难的周期性的数学竞赛，数学竞赛难以计算但是容易验证。
一旦某个矿工计算出了结果，他将这个结果和这段时间从网络中收集的交易信息一起打包，形成当前区块，并把这个区块广播到区块链中。
每个节点都可以验证这个结果是否正确，如果验证成功，节点会添加这个区块到自己的区块链数据库中。
2. 股权证明：PoS采用的是一种伪随机的方式，根据每个账户持有Stake的多少来选择每一轮的出块人，持有的股票越多，概率越大。
与PoW类似，如果持有50%的股票才有攻击网络的能力。
3. 容量证明：PoSpace类似与PoW，但是它要求大容量的硬盘空间，矿工通过向硬盘中写入指定大小的数据，来参与挖矿竞赛。
4. 实用拜占庭容错：PBFT是一种拜占庭问题解决的方案，属于多数人共识的一种。PBFT每轮选择出块节点，
该节点生成的区块需要通过一系列表决的方式获得至少三分之二参与共识节点的同意。PBFT的优点是块的产生不需要其他节点验证，
也就是说不会出现其它节点不同意这个区块内交易信息的问题。因此，PBFT算法所有节点得出的区块即最终区块。但是，
PBFT也有一个很大的问题，就是这个算法的时间复杂度会随着加入节点的增大而大幅度增长，因此如果参与节点超过25个PBFT的效率将会很差。

### 存在问题
1. 隐私问题
比特币和以太坊目前是不存在绝对的隐私的，只是存在一些匿名的手段。虽然无法知道用户是谁，但是这个用户的交易记录是可以被追踪的。
2. 智能合约过度自由
由于智能合约的门槛较低，容易出现质量参差不齐的智能合约，所以很可能会出现各种安全漏洞。

### 蜜獾来源
+ 如果你关注区块链，你可能会听说过蜜獾（平头哥），著名的比特币就被称为蜜獾的钱，意为恢复能力强和无所畏惧。
+ 为了纪念这种象征，一种新的共识协议诞生了，称为"Honey Badger Byzantine Fault Tolerant（HBBFT）Protocol"

### 共识是什么
+ 区块链技术中，共识算法是其中核心的一个组成部分。
+ 首先我们来思考一个问题：什么是共识？对于现实世界，共识就是一群人对一件或者多件事情达成一致的看法或者协议。
+ 那么在计算机世界当中，共识是什么呢？
    + 我的理解包含两个层面，第一个层面是点的层面，即多个节点对某个数据达成一致共识。
    + 第二个层面是线的层面，即多个节点对多个数据的顺序达成一致共识。这里的节点可以是任意的计算机设备，
    比如 pc电脑，笔记本，手机，路由器等，这里的数据可以是交易数据，状态数据等。
    + 其中对数据顺序达成一致共识是很多共识算法要解决的本质问题。

区块链本质也是一种去中心化的分布式账本系统，用于登记和发行数字化资产、产权凭证、积分等，以点对点的方式进行转账、支付和交易。
由于各种原因，点对点网络总会存在延迟，并且众多网络节点中的每一个节点所观察到的事务先后顺序不可能完全一致。
因此区块链系统需要设计一种机制对在一定时间窗口内发生的事务的先后顺序进行确立。
这种对特定时间段内事务的先后顺序达成共识的算法被称为“共识机制”。
    
### 共识算法
分为三大类：
1. 私链：私链的共识算法即区块链这个概念还没普及时的传统分布式系统里的共识算法，比如 zookeeper 的 zab 协议，就是类 paxos 算法的一种。
私链的适用环境一般是不考虑集群中存在作恶节点，只考虑因为系统或者网络原因导致的故障节点。
2. 联盟链：联盟链中，经典的代表项目是 Hyperledger 组织下的 Fabric 项目， Fabric0.6 版本使用的就是 pbft 算法。
联盟链的适用环境除了需要考虑集群中存在故障节点，还需要考虑集群中存在作恶节点。对于联盟链，每个新加入的节点都是需要验证和审核的。
3. 公链：公链不断需要考虑网络中存在故障节点，还需要考虑作恶节点，这一点和联盟链是类似的。
和联盟链最大的区别就是，公链中的节点可以很自由的加入或者退出，不需要严格的验证和审核。

### 拜占庭将军问题
拜占庭将军问题（Byzantine Generals Problem），是由Leslie Lamport在其同名论文中提出的分布式对等网络通信容错问题。
在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。
但有时候，系统中的成员计算机可能出错而发送错误的信息，
用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。
拜占庭将军问题被认为是容错性问题中最难的问题类型之一。

拜占庭将军的问题描述了与共识相关的两难问题。在这个经典问题中，一群将军必须达成协议，攻击或撤退敌人的据点。但是，它们位于城市周边的不同位置，除了来回发送信使之外无法进行通信。更复杂的是，可能会有恶意（拜占庭）将军故意发送不正确的信息。
如果他们全部攻击，他们将获胜。如果他们全都撤退，他们将多活一天。然而，如果一些攻击和一些撤退，攻击军队将遭受灾难性的损失。在这种情况下，达成可靠的共识是生死攸关的情况。
在没有过多挖掘细节的情况下，众所周知，只要少于1/3的将军是拜占庭人，就可以达成攻击或撤退的协议。他们通过来回传递签名的消息达成协议。签名不能伪造，任何将军都可以验证任何其他将军的签名。
区块链BFT共识也适用同样的原则。区块链中少于1/3的节点（通用）可能是恶意的，签名的消息在多轮中来回发送，并且签名必须是加密安全且可验证的。

### BFT -> PBFT
BFT从上世纪80年代开始被研究，目前已经是一个被研究得比较透彻的理论，具体实现都已经有现成的算法。
其中，PBFT是当中最著名的算法，PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法。
该算法是Miguel Castro和Barbara Liskov在1999年提出来的，解决了原始拜占庭容错算法效率不高的问题，
将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。

### BFT的问题
在分布式网络环境（例如区块链）中，某种形式的BFT对于维护功能，安全性和可靠性至关重要。但是，当前的实现存在问题。

1. 许多BFT网络依赖于时序假设来完成消息轮次。如果消息传递有困难，则选择并“调整”或更改超时参数。这可能导致未优化的网络，缓慢的恢复时间以及涉及消息调度的攻击的漏洞。
2. 一些BFT协议（例如Nakamoto共识 - 通常称为工作证明）不会产生块终结性。换句话说，几个矿工可能同时开采区块，导致临时的双链状态。这可能导致在验证事务之前等待很长时间，并且如果事务仅存在于短链上，则可以一起删除事务。
3. 工作证明区块链因其大量使用计算能力和不可持续的能源消耗而臭名昭着。要深入了解这个问题，请参阅比特币不断增长的能源问题和脱碳比特币。
4. BFT协议可能会产生较慢的吞吐率和低效的数据传输。
Honey Badger BFT解决了这些问题，通过一系列网络条件保持活跃（网络继续取得进展）和安全（所有诚实节点最终达成共识）。

### 为什么需要HBBFT
1. 不断发展的网络类型
    + 如上所述，PBFT自1999年以来一直存在。从那时起，很多事情发生了变化！未来的区块链网络可以包括移动电话，IOT设备和许多其他类型的节点。这些网络以不同的速度运行，并且难以正确设置定时参数。像TOR这样的网络也提供额外的安全性，但在数据传输速度方面显然是落后的。
    + HBBFT解决了时间问题，因为没有时序参数！它是一种异步协议，其中事务可以在不同时间到达不同节点。我们对消息传递的唯一假设是最终消息将被送达。区块速率与网络速度相匹配。
2. 面临的问题
    + 区块链是攻击者的诱人目标。他们拥有数十亿美元的加密货币，而分类账可以存储合同协议，所有权证明，法律记录和其他敏感信息。随着区块链技术的成熟，攻击的广度和深度也随之成熟。 DDOS攻击（其中节点充斥着无法处理的传入消息）对那些依赖时序运转的网络上显得更加有效。这类攻击旨在实现攻击消息调度来完全冻结网络。
    + HBBFT提供了几种防范攻击的功能：
        + 即使网络受到胁迫，异步机制也允许传递消息。某些消息可以传递而其他消息可以延迟，但仍会取得进展。
        + 一批加密交易达成协议;交易内容仅在达成共识后才会显示。这可以防止恶意节点选择性地阻止信息的审查攻击。如果节点不知道消息中的内容，则无法抑制特定信息。
        + 可以识别恶意节点并通过故障日志报告。然后，网络可以决定清除它们的最佳方法。
3. 提高效率
    + 大多数使用区块链的人都对更快的交易感兴趣。密码学和其他安全措施是资源密集型的，安全性始终是首要任务。然而，交易过程的微小变化可以带来更快的速度和更具可扩展性的网络。
    + 节点通信在HBBFT中进行了优化。每个块都是由几个节点的建议事务组合而成，因此每个节点只发送构成块的总事务百分比的信息。这些提议通过广播的形式进一步细分，其中节点将其提议段拆分并分发到网络中的其他节点。这样可以创建更小，一致的数据包与更快的块生产率。
    + 此外，HBBFT协议提供即时块终结性。只有在网络中的验证节点完成事务之后才会生成块。如果验证器对块进行了签名，则即使它是最新的块也会完成。这可以防止短暂的分叉，并创建一个不可变的，即时的交易分类帐。

## HBBFT
### 问题定义：原子广播
我们首先定义我们的网络模型和原子广播问题。我们设置网络会包含N个的节点，每个节点都有一个唯一的id（P0到PN-1）。节点接收交易作为输入，它们的目的就是达成某种特定顺序的交易的共识。
我们的模型特别适合已许可区块链的部署方案，其中事务可以由任意的客户端提交，但负责执行协议的节点是固定的。
原子广播语义允许我们抽象出任何特定于应用程序的细节，比如如何对事务进行内部预处理（为了防止重播攻击，例如，一个应用程序可能会定一个包含签名和序列号的事务）。
对于我们来说，事务只是唯一的字符串。在实践中，客户端会生成事务并将它们发送到所有节点，并在大多数节点签名后考虑提交它们。
为了简化我们的表示，我们没有显示地对客户端建模，而是假设事务是由对手提供的，并作为节点的输入。同样，一个事务一旦被节点输出就会被认为是提交的。
我们的系统模型会有以下假设：
+ 纯异步网络：我们假设每个节点都通过可靠的点对点网络通道连接，消息不会丢失，即消息最终都会被传递。由于网络节点中的消息会以任意顺序排列，假设节点会有无限的缓冲区且能处理所有接收到的消息。
+ 静态拜占庭错误：坏节点最多有f个，且总节点数N满足N大于等于3f+1。
+ 受信任的设置：假设节点可以在协议的初始阶段与受信任的处理者交互，这个阶段将用于建立公钥和私密共享。

### 概述
HoneyBadgerBFT算法中，节点接收交易作为输入并且存储在它们的缓冲区中。协议在epoch中执行，在每个epoch之后会有新的一批交易添加到提交日志中。
HoneyBadgerBFT使用的是异步通用子集（Asynchronous Common Subset，ACS），ACS原语允许每个节点提出一个值，并保证每个节点输出一个包含至少N-2f个正确节点的输入值的公共向量。
这个会带来两个挑战：
1. 实现审查弹性。ACS的开销直接依赖于每个节点提出的交易。我们可以通过每个节点提出不相交集合的交易来提高效率，因此，平均每个交易只会被一个节点提出。
但是这样实现会带来审查弹性的损害，因为ACS语义允许敌方选择哪些提出的交易最后会被提交，所以敌方可以选择性地审查交易。我们通过阀值加密来避免，可以防止对手了解哪些节点提出了什么交易。
2. 实际的吞吐量。尽管ACS理论上的可行性已为人知，但实际的性能方面尚不清楚。

### 从ACS构造HoneyBadgerBFT
ACS满足一下几个特性：
+ 合法性。如果一个正确节点输出一个集合v，则集合v的元素个数大于等于N-f且集合v包含至少N-2f个正确节点的输入。
+ 一致性。如果一个正确节点输出集合v，则每个节点都会输出集合v。
+ 整体性。如果N-f个正确节点接收一个输入，则所有正确节点会产生一个输出。