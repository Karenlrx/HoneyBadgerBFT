# 系统软件概述与设计
    本课题是纯软件实现，系统环境使用Go语言环境，软件开发工具使用的Go语言对应的集成开发环境Goland。
由于近年来Go语言比较热门，并且Go语言在区块链领域有着重要地位。更重要的是，相较于其它语言，
Go语言实现算法会更清晰，比如Go语言的Channel，它就能很好地模拟一个集群间的信道，
如果用C/C++实现就会陷入进程间通信甚至网络通信的泥潭，重点应该放在实现共识算法上。
    
## HoneyBadgerBFT整体框架
    首先定义网络模型和原子广播问题。假设网络会包含N个的节点，每个节点都有一个唯一的id（P0到PN-1）。
节点接收事务作为输入，它们的目的就是达成某种特定顺序的交易的共识。HoneyBadgerBFT特别适合已许可区块链的部署方案，
其中事务可以由任意的客户端提交，但负责执行协议的节点是固定的。原子广播语义允许我们抽象出任何特定于应用程序的细节，
比如如何对事务进行内部预处理，在实现中，事务只是一个随机值。为了简化表示，假设事务是由敌方提供的，并作为节点的输入。
同样，一个事务一旦被节点输出就会被认为是提交的。HoneyBadgerBFT的系统模型会有以下假设：
（1）纯异步网络：我们假设每个节点都通过可靠的点对点网络通道连接，消息不会丢失，即消息最终都会被传递。
由于网络节点中的消息会以任意顺序排列，假设节点会有无限的缓冲区且能处理所有接收到的消息。
（2）静态拜占庭错误：恶意节点最多有f个，且总节点数N满足N大于等于3f+1。
（3）受信任的设置：假设节点可以在协议的初始阶段与受信任的处理者交互，这个阶段将用于建立公钥和私密共享。
    
    HoneyBadgerBFT算法中，节点接收交易作为输入并且存储在它们的缓冲区中。协议在epoch中执行，在每个epoch之后会有新的一批交易添加到提交日志中。
HoneyBadgerBFT使用的是异步通用子集（Asynchronous Common Subset，ACS），ACS原语允许每个节点提出一个值，并保证每个节点输出一个包含至少N-2f个正确节点的输入值的公共向量。
这个会带来两个挑战：
（1）实现审查弹性。ACS的开销直接依赖于每个节点提出的交易，可以通过每个节点提出不相交集合的交易来提高效率，因此，平均每个交易只会被一个节点提出。
但是这样实现会带来审查弹性的损害，因为ACS语义允许敌方选择哪些提出的交易最后会被提交，所以敌方可以选择性地审查交易。
HoneyBadgerBFT通过阀值加密来避免，可以防止敌方了解哪些节点提出了什么交易。
（2）实际的吞吐量。尽管ACS理论上是可行性，但实际的性能方面还没有定论。

### HoneyBadger

### ACS

### RBC

### BBA