# 系统软件概述与设计
    本课题是纯软件实现，系统环境使用Go语言环境，软件开发工具使用的Go语言对应的集成开发环境Goland。
由于近年来Go语言比较热门，并且Go语言在区块链领域有着重要地位。更重要的是，相较于其它语言，
Go语言实现算法会更清晰，比如Go语言的Channel，它就能很好地模拟一个集群间的信道，
如果用C/C++实现就会陷入进程间通信甚至网络通信的泥潭，重点应该放在实现共识算法上。
    
## HoneyBadgerBFT整体框架
    如果对区块链比较了解，那么蜜獾（平头哥）应该不会陌生，比特币就称为蜜獾的钱，指动物的恢复能力强且无所畏惧。
为了纪念蜜獾这种象征，Honey Badger Byzantine Fault Tolerant Protocol诞生了。

    首先定义网络模型和原子广播问题。假设网络会包含N个的节点，每个节点都有一个唯一的id（P0到PN-1）。
节点接收事务作为输入，它们的目的就是达成某种特定顺序的事务的共识。HoneyBadgerBFT特别适合已许可区块链的部署方案，
其中事务可以由任意的客户端提交，但负责执行协议的节点是固定数量的。原子广播语义允许我们抽象出任何特定于应用程序的细节，
比如如何对事务进行内部预处理，在实现中，事务只是一个随机值。为了简化表示，假设事务是由敌方提供的，并作为节点的输入。
同样，一个事务一旦被节点输出就会被认为是提交的。HoneyBadgerBFT的系统模型会有以下假设：
（1）纯异步网络：假设每个节点都通过可靠的点对点网络通道连接，消息不会丢失，即消息最终都会被传递。
由于网络节点中的消息会以任意顺序排列，假设节点会有无限的缓存区且能处理所有接收到的消息。
（2）静态拜占庭错误：恶意节点最多有f个，且总节点数N满足N大于等于3f+1。
（3）受信任的设置：假设节点可以在协议的初始阶段与受信任的处理者交互，这个阶段将用于建立公钥和私密共享。

    异步性是HoneyBadgerBFT最重要的特性之一，传统的PBFT算法会依赖于网络传输的延迟在一定的范围内，
所以PBFT算法的实现里面需要一个计时器，类似TCP协议里的超时定时器，当这个定时器超时就会触发超时操作。

    HoneyBadgerBFT的每个节点没有像Raft算法那样区分是否是领导节点，即主节点，每个节点都公平地接收事务，
每个节点上都各自维护事务池。每轮开始的时候，随机在事务池里选出一部分事务，用ACS来发送这些事务。

    在算法实现中，为了简化网络系统，系统中每个节点通过一个公共的通道来进行消息传递，而没有采用实际实现的网络传输。
每个节点都有一个唯一的标识和一个存储事务的缓冲区，并且每个节点都会运行一个HoneyBadgerBFT算法的实例。
每个节点的事务存储都是基于内存的，生成的事务区块也没用数据库或者文件的形式存储下来，这是因为这些数据对于算法来说是不需要关心的，
我们应该关注的点应该在如何达成共识上，我实现的事务也只是用一个随机的数值来表示。

    HoneyBadgerBFT算法实现的总体流程如下：
（1）创建N个节点，并初始化节点的HoneyBadger和事务缓存区。
（2）对于每个节点，起三个协程：一个协程每隔一段时间随机产生一批事务，并输入到每个节点的HoneyBadger里；
一个协程启动HHoneyBadger，HoneyBadger开始运作（详细过程见下一小节）；
一个协程每隔一段时间拿到HoneyBadger的输出，删掉HoneyBadger事务缓冲区里已经提交的事务。
（3）最后是一个死循环，从公共的消息通道得到消息，触发HoneyBadger的处理函数，如此循环。

### HoneyBadger
    HoneyBadgerBFT算法中，节点接收交易作为输入并且存储在它们的缓冲区中。协议在epoch中执行，在每个epoch之后会有新的一批交易添加到提交日志中。
HoneyBadgerBFT使用的是异步通用子集（Asynchronous Common Subset，ACS），ACS原语允许每个节点提出一个值，并保证每个节点输出一个包含至少N-2f个正确节点的输入值的公共向量。
这个会带来两个挑战：
（1）实现审查弹性。ACS的开销直接依赖于每个节点提出的交易，可以通过每个节点提出不相交集合的交易来提高效率，因此，平均每个交易只会被一个节点提出。
但是这样实现会带来审查弹性的损害，因为ACS语义允许敌方选择哪些提出的交易最后会被提交，所以敌方可以选择性地审查交易。
HoneyBadgerBFT通过阀值加密来避免，可以防止敌方了解哪些节点提出了什么交易。
（2）实际的吞吐量。尽管ACS理论上是可行性，但实际的性能方面还没有定论。

    在HoneyBadger实例中，包含节点最基本的配置项：节点数、恶意节点数、当前epoch、该节点唯一id、其余节点的id、一批事务的最大在值，
每个epoch对应的ACS实例，存储事务的缓存区，记录每个epoch对应的提交的事务，还有一个用于不同协议之间传递的消息列表。

    HoneyBadger的总体流程如下：
（1）开始运行HoneyBadger之后，在之前就已经输入到事务缓存区的事务里随机选出一批事务，并输入到ACS实例里。
（2）HoneyBadger的处理函数依赖于ACS的处理函数，如果HoneyBadger当前的epoch与请求的epoch相等的话，则取出ACS中的输出并记录，
清理掉事务缓存区含结果的部分，然后epoch加一；如果epoch不相等，则清理无效的ACS，不做其它处理。

### Asynchronous Common Set
    ACS算法是HoneyBadgerBFT的基础和核心部分，由上面的算法流程可以看出，HoneyBadger还只是做了消息的加密解密操作，
 以及事务随机选择的处理，这些处理是为了提高算法的吞吐量，但是达成共识的部分还没有接触到。
 
    ACS满足以下三个特性：
（1）合法性。如果一个正确节点输出一个集合v，则集合v的元素个数大于等于N-f且集合v包含至少N-2f个正确节点的输入。
（2）一致性。如果一个正确节点输出集合v，则每个节点都会输出集合v。
（3）整体性。如果N-f个正确节点接收一个输入，则所有正确节点会产生一个输出。

    ACS协议由两个协议组成：RBC协议和BBA协议。ACS协议的主要功能是通过RBC协议广播事务，然后通过ABA协议形成一致的事务集合。
    
    在ACS实例中，包含节点基本的配置，每轮对应的RBC实例和BBA实例以及对应的结果，存储结果的缓存区，不同节点消息传递的消息列表，
以及一些ACS协议内部消息传递的通道。

    ACS的总体流程如下：
（1）ACS实例运行时，会起一个协程不断监听通道，有事务输入则处理事务，有消息到达则处理消息。
（2）将输入的事务传给RBC实例广播，如果这个时候没有给BBA实例提供输入，则给BBA实例输入1。
（3）如果接收到至少N-f个BBA实例输出的1，将其它还没有提供输入的BBA实例输入0，BBA实例的输出都记录下来。
（4）当所有BBA实例都已经完成，将结果是1的节点id记录下来，这些结果是1的节点的RBC输出组成ACS实例的输出。

### Reliable Broadcast
    RBC，可靠广播协议，通过使用纠错码算法减少节点之间的传输，在两次广播之后，第一次广播ECHO消息，第二次广播READY消息，
就可以在节点之间达成共识。

    PBFT在每一轮共识的时候，需要把事务块分发给所有其它节点，假设系统节点有100个节点，块大小为10M的话，
那么广播节点在这次广播就需要消耗100*10M=1G的带宽，因此广播节点的带宽很容易成为吞吐量的瓶颈。

    RBC协议本质上是通过广播发起者先使用纠错码算法将要广播的事务块分成N份，然后广播给N个节点。
节点使各自的网络带宽来广播这些部分事务块。这有点类似于BitTorrent协议，BitTorrent协议通过将资源块分成多份，
下载方可以从多个地方下载一个资源的不同部分，既达到加快下载速度的效果，也节省了服务器的资源。
因此，RBC协议减少了广播发起者的网络带宽，充分利用了所有节点的网络带宽，带宽消耗是PBFT的N分之一。

    这里有个问题就是如果有的节点没有接收到这些小块或者某些恶意节点故意不广播接收到的小块，那么将无法还原数据。
这也是上面需要先用纠错码算法的原因。假设恶意节点个数f=1/3*N，原本N个小块加上f个纠错码，总共N+f个小块，
只要节点接收到N+f个小块里的任意N个小块就可以完整地复原出原始事务块。

    在RBC实例中，包含节点基本的配置，广播节点id，存储其它节点传来的ECHO消息和READY消息，里德所罗门编码器及相关的分片数，
存储需要广播的消息，还有一些内部状态值及通道。

    RBC的总体流程如下：
（1）与ACS类似，RBC运行时也会起一个协程不断监听通道，有事务输入则处理事务，有消息到达则处理消息。
（2）将输入的事务块用里德所罗门算法分成N份，且有2f份冗余，分好的数据用默克尔树存储，将不同分支发给不同的节点。
（3）当节点接收到广播节点传来的数据，用ECHO消息包装好广播给其它节点。
（4）当节点接收到ECHO消息，需要验证这份数据是否合法，如果不合法就丢弃。当接收到N-f个合法的ECHO消息时，
如果此时还没有发送过READY消息，则广播READY消息，消息里包含默克尔树的根哈希值。
（5）当节点接收到f+1个默克尔树根哈希值相同的READY消息，并且仍未发送过READY消息，则广播READY消息。
（6）当节点接收到2f+1个READY消息后，根据里德所罗门编码恢复数据。

### Binary Byzantine Agreement
    二进制拜占庭一致性协议是一种标准的原语，它允许节点就一个位的数据达成一致。

    BBA算法满足以下三个条件：
（1）一致性。任意一个正确节点输出一个比特b，那么所有正确节点都输出b。
（2）最终性。如果所有正确节点都有输入，那么所有正确节点的输出都是b。
（3）合法性。任意一个正确节点输出b，那么至少一个正确节点的输入是b。

    在BBA实例中，包含